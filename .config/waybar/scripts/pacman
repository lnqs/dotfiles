#!/usr/bin/env python

import json
import os
import subprocess
import sys
from collections import namedtuple
from ctypes import CDLL, get_errno, c_int
from ctypes.util import find_library
from errno import EINTR
from fcntl import LOCK_EX, LOCK_NB, flock, ioctl
from io import FileIO
from os import fsencode, fsdecode
from select import poll
from struct import unpack_from, calcsize
from termios import FIONREAD

import dbus

CHECK_INTERVAL = 60 * 60 * 1000  # 1hr in ms
NOTIFICATION_IMAGE = "/usr/share/pixmaps/archlinux-logo.png"
CHECKUPDATES_DB_PATH = f"{os.environ['XDG_RUNTIME_DIR']}/waybar-pacman-db"


def log(text):
    print(text, file=sys.stderr)


class INotify(FileIO):
    # Based on <https://github.com/chrisjbillington/inotify_simple>

    Event = namedtuple("Event", ["wd", "mask", "cookie", "name"])

    ACCESS = 0x00000001  #: File was accessed
    MODIFY = 0x00000002  #: File was modified
    ATTRIB = 0x00000004  #: Metadata changed
    CLOSE_WRITE = 0x00000008  #: Writable file was closed
    CLOSE_NOWRITE = 0x00000010  #: Unwritable file closed
    OPEN = 0x00000020  #: File was opened
    MOVED_FROM = 0x00000040  #: File was moved from X
    MOVED_TO = 0x00000080  #: File was moved to Y
    CREATE = 0x00000100  #: Subfile was created
    DELETE = 0x00000200  #: Subfile was deleted
    DELETE_SELF = 0x00000400  #: Self was deleted
    MOVE_SELF = 0x00000800  #: Self was moved

    UNMOUNT = 0x00002000  #: Backing fs was unmounted
    Q_OVERFLOW = 0x00004000  #: Event queue overflowed
    IGNORED = 0x00008000  #: File was ignored

    ONLYDIR = 0x01000000  #: only watch the path if it is a directory
    DONT_FOLLOW = 0x02000000  #: don't follow a sym link
    EXCL_UNLINK = 0x04000000  #: exclude events on unlinked objects
    MASK_ADD = 0x20000000  #: add to the mask of an already existing watch
    ISDIR = 0x40000000  #: event occurred against dir
    ONESHOT = 0x80000000  #: only send event once

    _libc = None

    def __init__(self):
        libc_so = find_library("c")
        self._libc = self._libc or CDLL(libc_so, use_errno=True)
        FileIO.__init__(self, self._libc_call(self._libc.inotify_init1, 0x0), mode="rb")
        self._poller = poll()
        self._poller.register(self.fileno())

    def add_watch(self, path, mask):
        return self._libc_call(
            self._libc.inotify_add_watch, self.fileno(), fsencode(path), mask
        )

    def rm_watch(self, wd):
        self._libc_call(self._libc.inotify_rm_watch, self.fileno(), wd)

    def read(self, timeout=None):
        _EVENT_FMT = "iIII"
        _EVENT_SIZE = calcsize(_EVENT_FMT)

        data = self._readall()
        if not data and timeout != 0 and self._poller.poll(timeout):
            data = self._readall()

        pos = 0
        while pos < len(data):
            wd, mask, cookie, namesize = unpack_from(_EVENT_FMT, data, pos)
            pos += _EVENT_SIZE + namesize
            name = data[pos - namesize : pos].split(b"\x00", 1)[0]
            yield INotify.Event(wd, mask, cookie, fsdecode(name))

    def _readall(self):
        bytes_avail = c_int()
        ioctl(self, FIONREAD, bytes_avail)
        if not bytes_avail.value:
            return b""
        return os.read(self.fileno(), bytes_avail.value)

    @staticmethod
    def _libc_call(function, *args):
        while True:
            rc = function(*args)
            if rc != -1:
                return rc
            errno = get_errno()
            if errno != EINTR:
                raise OSError(errno, os.strerror(errno))


class NotificationClient:
    def __init__(self):
        self.interface = dbus.Interface(
            dbus.SessionBus().get_object(
                "org.freedesktop.Notifications", "/org/freedesktop/Notifications"
            ),
            "org.freedesktop.Notifications",
        )

    def notify(
        self,
        summary,
        body="",
        app_name="",
        actions=[],
        hints={},
        app_icon="",
        replaces_id=0,
        expire_timeout=-1,
    ):
        return self.interface.Notify(
            app_name,
            replaces_id,
            app_icon,
            summary,
            body,
            actions,
            hints,
            expire_timeout,
        )

    def close(self, notification_id):
        self.interface.CloseNotification(notification_id)


class Module:
    def __init__(self):
        self._notification_client = NotificationClient()
        self._update_notification_id = 0
        self._error_notification_id = 0

        self._inotify = INotify()
        self._inotify.add_watch("/var/lib/pacman", INotify.DELETE)

        self._last_pending_updates = []

    def run(self):
        os.makedirs(CHECKUPDATES_DB_PATH, exist_ok=True)

        while True:
            try:
                self._perform_check()
                self._wait_for_trigger()
            except Exception as e:
                self._publish_error(e)

    def _wait_for_trigger(self):
        events = list(self._inotify.read(timeout=CHECK_INTERVAL))
        return len(events) == 0 or any(e for e in events if e.name == "db.lock")

    def _perform_check(self):
        with open(f"{CHECKUPDATES_DB_PATH}/module.lck", "w") as lockfile:
            try:
                flock(lockfile, LOCK_EX | LOCK_NB)
                nosync = False
                log("Checking for arch updates (syncing)")
            except BlockingIOError:
                flock(lockfile, LOCK_EX)
                nosync = True
                log("Checking for arch updates (no sync)")

            pending_updates = self._call_checkupdates(nosync)
            if pending_updates != self._last_pending_updates:
                self._publish_pending_updates(pending_updates, not nosync)
                self._last_pending_updates = pending_updates

    def _publish_pending_updates(self, pending_updates, notify):
        print(
            json.dumps(
                {
                    "text": f"{len(pending_updates)}" if len(pending_updates) else "",
                    "tooltip": "\n".join(f"- {p}" for p in pending_updates)
                    if len(pending_updates)
                    else "No pending updates",
                }
            ),
            flush=True,
        )

        if notify and len(pending_updates):
            self._update_notification_id = self._notification_client.notify(
                "Updates available",
                f"{len(pending_updates)} updates pending",
                app_name="waybar-pacman",
                hints={
                    "urgency": 1,
                    "image-path": NOTIFICATION_IMAGE,
                },
                replaces_id=self._update_notification_id,
            )
        elif self._update_notification_id:
            self._notification_client.close(self._update_notification_id)

    def _publish_error(self, error):
        self._error_notification_id = self._notification_client.notify(
            "Failed to get updates",
            str(error),
            app_name="waybar-pacman",
            hints={
                "urgency": 2,
                "image-path": NOTIFICATION_IMAGE,
            },
            replaces_id=self._error_notification_id,
        )

    @staticmethod
    def _call_checkupdates(nosync):
        result = subprocess.run(
            ["checkupdates", "--nocolor"] + (["--nosync"] if nosync else []),
            capture_output=True,
            env={"CHECKUPDATES_DB": CHECKUPDATES_DB_PATH},
        )
        if len(result.stderr):
            log(result.stderr.decode())
        if result.returncode == 1:
            raise RuntimeError(result.stderr.decode().replace("==> ERROR: ", ""))
        return [
            pkg.strip() for pkg in result.stdout.decode().split("\n") if pkg.strip()
        ]


if __name__ == "__main__":
    Module().run()
