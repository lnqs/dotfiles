#!/usr/bin/env python

import http.client
import json
import os
import sys
import urllib.parse
from time import sleep
from xml.etree import ElementTree


def log(text):
    print(text, file=sys.stderr)


class Syncthing:
    _CONFIG_FILE = f"{os.environ['XDG_STATE_HOME']}/syncthing/config.xml"
    _EVENTS = [
        "PendingDevicesChanged",
        "PendingFoldersChanged",
        "DeviceConnected",
        "DeviceDisconnected",
        "FolderCompletion",
        "LocalChangeDetected",
        "RemoteChangeDetected",
        "FolderWatchStateChanged",
    ]

    class HTTPException(Exception):
        def __init__(self, status, body):
            self.status = status
            self.body = body

    def __init__(self):
        self._syncthing_config = ElementTree.parse(self._CONFIG_FILE)
        self._state = {
            "completion": self.completion,
            "devices_connected": len(self.connections),
            "pending_devices": len(self.pending_devices),
            "pending_folders": len(self.pending_folders),
            "last_change": None,
            "has_errors": bool(self.folder_errors),
        }

    def listen(self):
        yield self._state

        previous_events = self._request("/events", {"events": ",".join(self._EVENTS)})
        last_seen_id = previous_events[-1]["id"] if previous_events else 0
        del previous_events

        while True:
            log("Starting long poll for Syncthing events")
            events = self._request(
                "/events",
                {
                    "since": last_seen_id,
                    "timeout": 10 * 60,
                    "events": ",".join(self._EVENTS),
                },
            )
            for event in events:
                self._handle_event(event)

            if events:
                last_seen_id = events[-1]["id"]
                yield self._state

    @property
    def address(self):
        return self._syncthing_config.find("./gui/address").text

    @property
    def api_key(self):
        return self._syncthing_config.find("./gui/apikey").text

    @property
    def folders(self):
        return self._request("/config/folders")

    @property
    def folder_errors(self):
        errors = {}
        for folder in self.folders:
            response = self._request("/folder/errors", {"folder": folder["id"]})
            if response["errors"]:
                errors[folder["id"]] = response["errors"]
        return errors

    @property
    def completion(self):
        return self._request("/db/completion")["completion"]

    @property
    def connections(self):
        connections = self._request("/system/connections")["connections"]
        return [
            {"id": id, **data}
            for id, data in connections.items()
            if not data["isLocal"]
        ]

    @property
    def pending_devices(self):
        devices = self._request("/cluster/pending/devices")
        return [{"id": id, **data} for id, data in devices.items()]

    @property
    def pending_folders(self):
        folders = self._request("/cluster/pending/folders")
        return [{"id": id, **data} for id, data in folders.items()]

    def _handle_PendingDevicesChanged(self, event):
        self._state["pending_devices"] = len(self.pending_devices)

    def _handle_PendingFoldersChanged(self, event):
        self._state["pending_folders"] = len(self.pending_folders)

    def _handle_DeviceConnected(self, event):
        self._state["devices_connected"] = len(self.connections)

    def _handle_DeviceDisconnected(self, event):
        self._state["devices_connected"] = len(self.connections)

    def _handle_FolderCompletion(self, event):
        self._state["completion"] = self.completion

    def _handle_LocalChangeDetected(self, event):
        self._state["last_change"] = {
            "path": event["data"]["path"],
            "action": event["data"]["action"],
            "change": "local",
        }

    def _handle_RemoteChangeDetected(self, event):
        self._state["last_change"] = {
            "path": event["data"]["path"],
            "action": event["data"]["action"],
            "change": "remote",
        }

    def _handle_FolderWatchStateChanged(self, event):
        self._state["has_errors"] = bool(self.folder_errors)

    def _handle_event(self, event):
        getattr(self, f"_handle_{event['type']}")(event)

    def _request(self, path, params={}):
        splitted_address = urllib.parse.urlsplit(f"//{self.address}")
        serialized_params = f"?{urllib.parse.urlencode(params)}" if params else ""

        connection = http.client.HTTPConnection(
            host=splitted_address.hostname, port=splitted_address.port
        )

        connection.request(
            "GET",
            f"/rest{path}{serialized_params}",
            headers={"X-Api-Key": self.api_key},
        )
        response = connection.getresponse()
        body = response.read()

        if response.status < 200 or response.status >= 300:
            raise self.HTTPException(response.status, body)

        return json.loads(body)


def write_output(text, alt, tooltip):
    print(
        json.dumps({"text": text, "alt": alt, "tooltip": tooltip}),
        flush=True,
    )


def write_state(state):
    if state["has_errors"]:
        text = "error"
    elif state["completion"] == 100:
        text = "idle"
    else:
        text = "syncing"

    if state["has_errors"] or state["pending_devices"] or state["pending_folders"]:
        alt = "interaction-required"
    elif state["completion"] == 100:
        alt = "idle"
    else:
        alt = "syncing"

    tooltip = []
    tooltip.append("idle" if state["completion"] == 100 else "syncing")

    if state["has_errors"]:
        tooltip.append("<span foreground='#e67e80'>syncing errors</span>")

    if state["pending_devices"] or state["pending_folders"]:
        tooltip.append(f"{state['pending_devices']} pending devices")
    if state["pending_folders"]:
        tooltip.append(f"{state['pending_folders']} pending folders")

    tooltip.append(f"{state['devices_connected']} devices connected")

    if state["last_change"]:
        tooltip.append(
            f"Last change: {state['last_change']['action']} {state['last_change']['path']} ({state['last_change']['change']})"
        )

    write_output(text, alt, "\n".join(tooltip))


def main():
    backoff = 0

    while True:
        try:
            syncthing = Syncthing()
            for state in syncthing.listen():
                write_state(state)
                backoff = 0

        except Exception as e:
            backoff = min(backoff + 3, 60 * 10)
            log(
                f"Error fetching Syncthing status (retrying with backoff {backoff}): {e}"
            )
            write_output(
                "Disconnected",
                "disconnected",
                "Can't connect to Syncthing",
            )
            sleep(backoff)


if __name__ == "__main__":
    main()
