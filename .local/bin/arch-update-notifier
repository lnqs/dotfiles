#!/usr/bin/env python

import dbus
import json
import os
import socket
import subprocess
import sys
from collections import namedtuple
from ctypes import CDLL, get_errno, c_int
from ctypes.util import find_library
from dbus.mainloop.glib import DBusGMainLoop
from errno import EINTR
from fcntl import flock, LOCK_EX, LOCK_NB, ioctl
from gi.repository import GLib, Gio
from io import FileIO
from os import fsencode, fsdecode
from struct import unpack_from, calcsize
from termios import FIONREAD

CHECK_INTERVAL = 60 * 60  # 1hr
NOTIFICATION_IMAGE = "/usr/share/pixmaps/archlinux-logo.png"
DB_PATH = f"{os.environ['XDG_RUNTIME_DIR']}/update-notifier-db"


def log(*args):
    print(*args, file=sys.stderr)


class INotify(FileIO):
    # Based on <https://github.com/chrisjbillington/inotify_simple>

    Event = namedtuple("Event", ["wd", "mask", "cookie", "name"])

    ACCESS = 0x00000001  #: File was accessed
    MODIFY = 0x00000002  #: File was modified
    ATTRIB = 0x00000004  #: Metadata changed
    CLOSE_WRITE = 0x00000008  #: Writable file was closed
    CLOSE_NOWRITE = 0x00000010  #: Unwritable file closed
    OPEN = 0x00000020  #: File was opened
    MOVED_FROM = 0x00000040  #: File was moved from X
    MOVED_TO = 0x00000080  #: File was moved to Y
    CREATE = 0x00000100  #: Subfile was created
    DELETE = 0x00000200  #: Subfile was deleted
    DELETE_SELF = 0x00000400  #: Self was deleted
    MOVE_SELF = 0x00000800  #: Self was moved

    UNMOUNT = 0x00002000  #: Backing fs was unmounted
    Q_OVERFLOW = 0x00004000  #: Event queue overflowed
    IGNORED = 0x00008000  #: File was ignored

    ONLYDIR = 0x01000000  #: only watch the path if it is a directory
    DONT_FOLLOW = 0x02000000  #: don't follow a sym link
    EXCL_UNLINK = 0x04000000  #: exclude events on unlinked objects
    MASK_ADD = 0x20000000  #: add to the mask of an already existing watch
    ISDIR = 0x40000000  #: event occurred against dir
    ONESHOT = 0x80000000  #: only send event once

    _libc = None

    def __init__(self):
        libc_so = find_library("c")
        self._libc = self._libc or CDLL(libc_so, use_errno=True)
        FileIO.__init__(self, self._libc_call(self._libc.inotify_init1, 0x0), mode="rb")

    def add_watch(self, path, mask):
        return self._libc_call(
            self._libc.inotify_add_watch, self.fileno(), fsencode(path), mask
        )

    def read(self):
        _EVENT_FMT = "iIII"
        _EVENT_SIZE = calcsize(_EVENT_FMT)

        bytes_avail = c_int()
        ioctl(self, FIONREAD, bytes_avail)
        if not bytes_avail.value:
            return b""
        data = os.read(self.fileno(), bytes_avail.value)

        pos = 0
        while pos < len(data):
            wd, mask, cookie, namesize = unpack_from(_EVENT_FMT, data, pos)
            pos += _EVENT_SIZE + namesize
            name = data[pos - namesize : pos].split(b"\x00", 1)[0]
            yield INotify.Event(wd, mask, cookie, fsdecode(name))

    @staticmethod
    def _libc_call(function, *args):
        while True:
            rc = function(*args)
            if rc != -1:
                return rc
            errno = get_errno()
            if errno != EINTR:
                raise OSError(errno, os.strerror(errno))


class NetworkManager:
    def __init__(self):
        self._connected_listeners = []

        self.interface = dbus.Interface(
            dbus.SystemBus().get_object(
                "org.freedesktop.NetworkManager", "/org/freedesktop/NetworkManager"
            ),
            "org.freedesktop.NetworkManager",
        )

        self.interface.connect_to_signal(
            "StateChanged", self._on_connection_state_change
        )
        self.is_connected = self.interface.state() == 70

    def add_is_connected_listener(self, callback):
        self._connected_listeners.append(callback)

    def _on_connection_state_change(self, state):
        is_connected = state == 70
        if is_connected != self.is_connected:
            self.is_connected = is_connected
            for listener in self._connected_listeners:
                listener(is_connected)


class LockfileWatch:
    def __init__(self):
        self._lockfile_listeners = []

        self._inotify = INotify()
        self._inotify.add_watch("/var/lib/pacman", INotify.DELETE)
        channel = GLib.IOChannel(self._inotify.fileno())
        GLib.io_add_watch(channel, GLib.IOCondition.IN, self._on_inotify)

    def add_lockfile_listener(self, callback):
        self._lockfile_listeners.append(callback)

    def _on_inotify(self, source, condition):
        events = self._inotify.read()
        lock_deleted = any(e for e in events if e.name == "db.lck")
        if lock_deleted:
            for listener in self._lockfile_listeners:
                listener()
        return True


class Timer:
    def __init__(self, interval):
        self._listeners = []
        GLib.timeout_add_seconds(interval, self._on_timeout)

    def add_listener(self, callback):
        self._listeners.append(callback)

    def _on_timeout(self):
        for listener in self._listeners:
            listener()
        return True


class Server:
    def __init__(self):
        self._connection_listeners = []
        self._connections = []
        self._socket_service = Gio.SocketService()
        self._socket_service.connect("incoming", self._on_incoming)

    def start(self):
        try:
            os.unlink(f"{DB_PATH}/notifier.socket")
        except FileNotFoundError:
            pass

        server_socket = Gio.Socket.new(
            Gio.SocketFamily.UNIX, Gio.SocketType.STREAM, Gio.SocketProtocol.DEFAULT
        )
        server_socket.bind(
            Gio.UnixSocketAddress.new(f"{DB_PATH}/notifier.socket"), True
        )
        server_socket.listen()
        self._socket_service.add_socket(server_socket)

        self._socket_service.start()

    def add_connection_listener(self, callback):
        self._connection_listeners.append(callback)

    def broadcast(self, data):
        for connection in self._connections:
            connection.get_output_stream().write_all(data)

    def _on_incoming(self, socket_service, connection, source):
        log("new client connected")
        self._connections.append(connection)
        user_data = [connection]
        tag = GLib.io_add_watch(
            connection.get_socket().get_fd(),
            GLib.IOCondition.IN,
            self._on_connection_readable,
            user_data,
        )
        user_data.append(tag)
        for listener in self._connection_listeners:
            listener(connection)

    def _on_connection_readable(self, fd, condition, user_data):
        connection, tag = user_data
        length = connection.get_input_stream().read()
        if length != 0:
            log("client send data, ignoring")
        else:
            log(f"client disconnected")
            GLib.Source.remove(tag)
            self._connections.remove(connection)
            connection.close()

        return True


class NotificationClient:
    def __init__(self):
        self.interface = None

    def _ensure_connection(self):
        if not self.interface:
            self.interface = dbus.Interface(
                dbus.SessionBus().get_object(
                    "org.freedesktop.Notifications", "/org/freedesktop/Notifications"
                ),
                "org.freedesktop.Notifications",
            )

    def notify(
        self,
        summary,
        body="",
        app_name="",
        actions=[],
        hints={},
        app_icon="",
        replaces_id=0,
        expire_timeout=-1,
    ):
        try:
            self._ensure_connection()
            return self.interface.Notify(
                app_name,
                replaces_id,
                app_icon,
                summary,
                body,
                actions,
                hints,
                expire_timeout,
            )
        except dbus.exceptions.DBusException as e:
            log(f"failed to connect to notification service: {e}")

    def close(self, notification_id):
        try:
            self._ensure_connection()
            self.interface.CloseNotification(notification_id)
        except dbus.exceptions.DBusException as e:
            log(f"failed to connect to notification service: {e}")


class Daemon:
    def __init__(self):
        self._last_pending_updates = []
        self._update_notification_id = 0
        self._error_notification_id = 0
        
        os.makedirs(DB_PATH, exist_ok=True)

        DBusGMainLoop(set_as_default=True)

        self._timer = Timer(CHECK_INTERVAL)
        self._lockfile_watch = LockfileWatch()
        self._networkmanager = NetworkManager()
        self._server = Server()
        self._notification_client = NotificationClient()

        self._loop = GLib.MainLoop()

    def run(self):
        with open(f"{DB_PATH}/notifier.lck", "w") as lock:
            try:
                flock(lock, LOCK_EX | LOCK_NB)
                log("acquired lock")
            except BlockingIOError:
                raise RuntimeError(
                    "couldn't acquire lock, is another instance running?"
                )

            self._timer.add_listener(self._on_timeout)
            self._lockfile_watch.add_lockfile_listener(self._on_lockfile_delete)
            self._networkmanager.add_is_connected_listener(
                self._on_connection_state_change
            )
            self._server.add_connection_listener(self._on_client_connection)
            self._server.start()

            if self._networkmanager.is_connected:
                self._perform_check()
            else:
                log("skipping initial check due to missing network connectivity")

            self._loop.run()

    def _on_timeout(self):
        log("waiting time exceeded")
        self._perform_check()

    def _on_lockfile_delete(self):
        log("pacdb lockfile deleted")
        self._perform_check()

    def _on_connection_state_change(self, is_connected):
        log(
            f"network connectivity changed to {'connected' if is_connected else 'disconnected'}"
        )
        if is_connected:
            self._perform_check()

    def _on_client_connection(self, connection):
        data = json.dumps(self._last_pending_updates) + "\n"
        connection.get_output_stream().write_all(data.encode())

    def _perform_check(self):
        if not self._networkmanager.is_connected:
            log("skipping check due to missing connectivity")

        log("checking for updates")
        try:
            pending_updates = self._call_checkupdates()
            if sorted(pending_updates) != sorted(self._last_pending_updates):
                log(f"found {len(pending_updates)} new updates")
                self._publish_pending_updates(pending_updates)
                self._last_pending_updates = pending_updates
            else:
                log("no new updates")
        except RuntimeError as e:
            log(f"failed to get updates: {e}")
            self._publish_error(e)

    def _publish_pending_updates(self, pending_updates):
        data = json.dumps(pending_updates) + "\n"
        self._server.broadcast(data.encode())
        
        if len(pending_updates):
            self._update_notification_id = self._notification_client.notify(
                "Updates available",
                f"{len(pending_updates)} updates pending",
                app_name="arch-update-notifier",
                hints={
                    "urgency": 1,
                    "image-path": NOTIFICATION_IMAGE,
                },
                replaces_id=self._update_notification_id,
            )
        elif self._update_notification_id:
            self._notification_client.close(self._update_notification_id)
    
    def _publish_error(self, error):
        self._error_notification_id = self._notification_client.notify(
            "Failed to get updates",
            str(error),
            app_name="arch-update-notifier",
            hints={
                "urgency": 2,
                "image-path": NOTIFICATION_IMAGE,
            },
            replaces_id=self._error_notification_id,
        )

    @staticmethod
    def _call_checkupdates():
        result = subprocess.run(
            ["checkupdates", "--nocolor"],
            capture_output=True,
            env={"CHECKUPDATES_DB": DB_PATH},
        )
        if len(result.stderr):
            log(result.stderr.decode())
        if result.returncode == 1:
            raise RuntimeError(result.stderr.decode().replace("==> ERROR: ", ""))
        return [
            pkg.strip() for pkg in result.stdout.decode().split("\n") if pkg.strip()
        ]


if __name__ == "__main__":
    Daemon().run()
